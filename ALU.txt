library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

ENTITY ALU IS
	PORT(
		Ain :  IN  STD_LOGIC_VECTOR(31 DOWNTO 0); -- INPUTS A/B from Data Path
		Bin :  IN  STD_LOGIC_VECTOR(31 DOWNTO 0); 
		ADDop : IN STD_LOGIC; -- Following are Operation signals -> when 1 they will activate their component and do necessary computations
		SUBop : IN STD_LOGIC;
		MULop : IN STD_LOGIC; 
		DIVop : IN STD_LOGIC;
		SHRop : IN STD_LOGIC;
		SHLop : IN STD_LOGIC;
		ROTRop : IN STD_LOGIC; 
		ROTLop : IN STD_LOGIC;
		ANDop : IN STD_LOGIC;
		ORop : IN STD_LOGIC;
		NEGop : IN STD_LOGIC; 
		NOTop : IN STD_LOGIC;
		IncPCop : IN STD_LOGIC; -- signal to increment PC counter within ALU
		ALU_Output :  OUT  STD_LOGIC_VECTOR(63 DOWNTO 0) -- Z holds the results of the operation on A/B and will drive the bus --> must be 64b for MUL
		);
END ENTITY ALU;

ARCHITECTURE behavioural OF ALU IS
	-- creating component for each operation --> DO WE STILL NEED ADD/SUB/PCInc based on email ????	
	COMPONENT Mul32b IS -- Booth 
		PORT(dA	: STD_LOGIC_VECTOR(31 DOWNTO 0);
		     dB  : STD_LOGIC_VECTOR(31 DOWNTO 0);
		     output: STD_LOGIC_VECTOR(63 DOWNTO 0) -- booth uses double the bits as result
		     );
	END COMPONENT Mul32b;

	COMPONENT Div32b IS
		PORT(dividend	: STD_LOGIC_VECTOR(31 DOWNTO 0);
			  divisor  : STD_LOGIC_VECTOR(31 DOWNTO 0);
			  output: STD_LOGIC_VECTOR(31 DOWNTO 0);
			  remainder: STD_LOGIC_VECTOR(31 DOWNTO 0)
		     );
	END COMPONENT Div32b;

	COMPONENT Shift_right_op IS
		PORT(data	: STD_LOGIC_VECTOR(31 DOWNTO 0);
			  distance : STD_LOGIC_VECTOR(31 DOWNTO 0);
			  SHRresult : STD_LOGIC_VECTOR(31 DOWNTO 0)
			);
	END COMPONENT Shift_right_op;

	COMPONENT Shift_left_op IS
		PORT(data	: STD_LOGIC_VECTOR(31 DOWNTO 0);
		     distance : STD_LOGIC_VECTOR(4 DOWNTO 0); -- only needs to count 0->31
		     SHLresult : STD_LOGIC_VECTOR(31 DOWNTO 0)
		     );
	END COMPONENT Shift_left_op;

	COMPONENT Rotate_right_op IS
		PORT(data	: STD_LOGIC_VECTOR(31 DOWNTO 0);
		  distance : STD_LOGIC_VECTOR(31 DOWNTO 0);
		  RORresult : STD_LOGIC_VECTOR(31 DOWNTO 0)
		  );
	END COMPONENT Rotate_right_op;

	COMPONENT rotate_left_op IS
		PORT(data	: STD_LOGIC_VECTOR(31 DOWNTO 0);
		     distance : STD_LOGIC_VECTOR(31 DOWNTO 0);
		     ROLresult : STD_LOGIC_VECTOR(31 DOWNTO 0)
		     );
	END COMPONENT Rotate_left_op;

	COMPONENT Negate IS
		PORT(data	: STD_LOGIC_VECTOR(31 DOWNTO 0);
		     NEGresult	: STD_LOGIC_VECTOR(31 DOWNTO 0)
		     );
	END COMPONENT Negate;


-- Define Required Signals for Architecture --> all the outputs should be mapped to proper components
SIGNAL Mul32b_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Div32b_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Div32b_remainder : STD_LOGIC_VECTOR(31 DOWNTO 0); -- must return quotient/remainder
SIGNAL Shift_right_op_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Shift_left_op_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Rotate_right_op_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Rotate_left_op_output : STD_LOGIC_VECTOR(31 DOWNTO 0);
SIGNAL Negate_output: STD_LOGIC_VECTOR(31 DOWNTO 0);

-- Now begins start of architecture
BEGIN
-- Map The Instantiated Components To The Local Signals Of ALU  
	ALU_Mul32b  			:	PCInc PORT MAP(A => Ain, B => Bin, product => Mul32b_output);
	ALU_Div32b  			:	PCInc PORT MAP(numer => Ain, denom => Bin, quotient => Div32b_output, remainder => Div32b_remainder );
	ALU_Shift_right_op  	:	PCInc PORT MAP(A => Ain, distance => Bin(4 DOWNTO 0), SHRresult => Shift_right_op_output); -- 5 bits to represent 63b-0 of data in
	ALU_Shift_left_op  	:	PCInc PORT MAP(A => Ain, distance => Bin(4 DOWNTO 0), SHLresult => Shift_left_op_output);
	ALU_Rotate_right_op  :	PCInc PORT MAP(A => Ain, distance => Bin(4 DOWNTO 0), RORresult => Rotate_right_op_output);
	ALU_Rotate_left_op  	:	PCInc PORT MAP(A => Ain, distance => Bin(4 DOWNTO 0), ROLresult => Rotate_left_op_output);
	ALU_Negate  			:	PCInc PORT MAP(A => Ain, NEGresult => Negate_output);
	
-- Sensitivity List Then Evaluate What Signal Was Called WHich Will Then Activate The Proper Component And Return A Single Output
	ALU_proc	: PROCESS(Ain, Bin, ADDop, SUBop, MULop, DIVop, SHRop, SHLop, ROTRop, ROTLop, ANDop, ORop, NEGop, NOTop, IncPCop)
		BEGIN
			IF ADDop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0'); 
				ALU_Output(31 DOWNTO 0) <= (Ain + Bin); 
			ELSIF SUBop  = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= (Ain - Bin);
			ELSIF MULop THEN
				ALU_Output <= Mul32b_output; -- all 64b are used so full output is assigned
			ELSIF DIVop THEN
				ALU_Output(63 DOWNTO 32) <= Div32b_output; -- all 64b are used to separate quotient from remainder
				ALU_Output(31 DOWNTO 0) <= Div32b_remainder;
			ELSIF SHRop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= Shift_right_op_output; -- most conditions are assigned to signals that are mapped to components
			ELSIF SHLop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= ALU_Shift_left_op_output;
			ELSIF ROTRop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= ALU_Rotate_right_op_output;
			ELSIF ROTLop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= ALU_Rotate_left_op_output;
			ELSIF ANDop  = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0'); 
				ALU_Output(31 DOWNTO 0) <= Ain AND Bin; -- using built in operations
			ELSIF ORop = '1' THEN 
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= Ain OR Bin; -- using built in operations
			ELSIF NEGop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= ALU_Negate_output;
			ELSIF NOTop = '1' THEN 
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= NOT Ain; -- using built in operations
			ELSIF IncPCop = '1' THEN
				ALU_Output(63 DOWNTO 32) <= (OTHERS => '0');
				ALU_Output(31 DOWNTO 0) <= Ain + "00000000000000000000000000000001"; -- Not sure if this is right ****
			END IF;	
	END PROCESS;
END ARCHITECTURE behavioural;
